# vwzsh

#*******************************************************************************
#
# base
# local option
#
#*******************************************************************************
export VWZ="$HOME/.vwz"
export ZSH=$VWZ

export PATH=$PATH:$VWZ:$ZSH

## cache base direcotry
VWZCACHE="$HOME/.cache/vwz"
mkdir -p $VWZCACHE
## language
export LANG=en_US.UTF-8
## time
export LC_TIME=en_US.UTF-8
## prefix
export PREFIX=/usr/local

#*******************************************************************************
#
# theme
# zsh theme
#
#*******************************************************************************
autoload -U colors && colors
setopt promptsubst

vwz_setup_git_prompt () {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        unset git_prompt
        return 0
    fi

    local git_status_dirty git_status_stash git_branch

    if [ "$(git --no-optional-locks status --untracked-files='no' --porcelain)" ]; then
        git_status_dirty='%F{green}*'
    else
        unset git_status_dirty
    fi

    if [ "$(git stash list)" ]; then
        git_status_stash="%F{yellow}▲"
    else
        unset git_status_stash
    fi

    git_branch="$(git symbolic-ref HEAD 2>/dev/null)"
    git_branch="${git_branch#refs/heads/}"

    if [ "${#git_branch}" -ge 24 ]; then
        git_branch="${git_branch:0:21}..."
    fi

    git_branch="${git_branch:-no branch}"

    git_prompt="$fg[red]git $fg[blue][$fg[yellow]${git_branch}${git_status_dirty}${git_status_stash}$fg[blue]]"

	print -- $git_prompt
}

function vwz_prompt_theme () {
	local git_info=$(vwz_setup_git_prompt)
	print -- "%{$terminfo[bold]$fg[blue]%}#%{$reset_color%} \
%{$fg[cyan]%n%} %{$fg[green]%}.%{$fg[green]%~%} %{$fg[white]%}[%{%*%}] \
${git_info}
%{$terminfo[bold]$fg[red]%}$ %{$reset_color%}"
}

zle_highlight=(region:bg=magenta
			   special:bold
			   isearch:underline)

#*******************************************************************************
#
# complete
# zsh auto complete
#
#*******************************************************************************
autoload -U compinit && compinit

setopt AUTO_LIST # 在不明确的完成时自动列出选项
setopt AUTO_MENU # 在第二次连续请求完成后自动使用菜单完成
setopt AUTO_REMOVE_SLASH # 如果补全产生的最后一个字符是斜杠，而键入的下一个字符是单词定界符、斜杠或结束命令的字符（如分号或与号），则删除斜杠
setopt ALWAYS_TO_END # 标在单词内执行补全，并插入完整补全，则光标将移动到单词的末尾
setopt BASH_AUTO_LIST
setopt COMPLETE_IN_WORD # 如果未设置，则如果开始完成，光标将设置到单词的末尾。否则它会留在那里并且从两端完成
setopt COMPLETE_ALIASES # 防止命令行上的别名在尝试完成之前被内部替换。其效果是使别名成为完成目的的独特命令
setopt GLOB_COMPLETE #
setopt MENU_COMPLETE # 不列出可能性，直接插入第一项

zstyle ':completion:*' rehash true
#开启此选项，补全时会直接选中菜单项

zstyle ':completion:*:*:*:*:*' menu select
#自动补全缓存
zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path .zcache
zstyle ':completion:*:cd:*' ignore-parents parent pwd

#自动补全选项
zstyle ':completion:*' verbose yes
zstyle ':completion:*' menu select
zstyle ':completion:*:*:default' force-list always
zstyle ':completion:*' select-prompt '%SSelect:  lines: %L  matches: %M  [%p]'

zstyle ':completion:*:match:*' original only
zstyle ':completion::prefix-1:*' completer _complete
zstyle ':completion:predict:*' completer _complete
zstyle ':completion:incremental:*' completer _complete _correct
zstyle ':completion:*' completer _complete _prefix _correct _prefix _match _approximate

#路径补全
zstyle ':completion:*' expand 'yes'
zstyle ':completion:*' squeeze-shlashes 'yes'
zstyle ':completion::complete:*' '\\'

#彩色补全菜单
# eval $(dircolors -b)
LS_COLORS='no=00;37:fi=00:di=00;33:ln=04;36:pi=40;33:so=01;35:bd=40;33;01:'
export CLICOLOR=1
export LS_COLORS
zmodload zsh/complist
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'

#修正大小写
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'

#错误校正
zstyle ':completion:*' completer _complete _match _approximate
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric

#kill 命令补全
compdef pkill=kill
compdef pkill=killall
zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:*:*:*:processes' force-list always
zstyle ':completion:*:processes' command 'ps -au$USER'

#补全类型提示分组
zstyle ':completion:*:matches' group 'yes'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:options' auto-description '%d'
zstyle ':completion:*:descriptions' format $'\e[01;33m -- %d --\e[0m'
zstyle ':completion:*:messages' format $'\e[01;35m -- %d --\e[0m'
zstyle ':completion:*:warnings' format $'\e[01;31m -- No Matches Found --\e[0m'
zstyle ':completion:*:corrections' format $'\e[01;32m -- %d (errors: %e) --\e[0m'

# cd ~ 补全顺序
zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'

#*******************************************************************************
#
# edit
# zsh edit
#
#*******************************************************************************
## 在命令前增加 sudo
vwe_sudo_command_line () {
	[[ -z $BUFFER ]] && zle up-history
	[[ $BUFFER != sudo\ * ]] && BUFFER="sudo $BUFFER"
	zle end-of-line # 光标移动到行尾
}

zle -N vwe_sudo_command_line

bindkey "\e\e" vwe_sudo_command_line

#*******************************************************************************
#
# directory
# zsh extend directory
#
#*******************************************************************************
setopt autocd # 不需要使用`cd`
setopt auto_pushd # 在堆中维护目录
setopt pushd_ignore_dups # 目录中删除重复项
setopt pushdminus # 反转 + 和 - 的含义
setopt pushdsilent # 在 pushd 或 popd 之后不要打印目录堆栈
setopt pushdtohome # 没有参数的 pushd 就像‘pushd $HOME’一样
setopt interactivecomments # 允许在命令中添加注释

setopt magicequalsubst
setopt numericglobsort
setopt extendedglob # 启用扩展通配
setopt longlistjobs # 使用jobs时显示PID
setopt nobeep # 不发出声音

# 返回上个文件夹
vwz_cd_undo () {
  popd      > /dev/null
  zle reset-prompt
}

# 跳转到父文件夹
vwz_cd_parent() {
  pushd .. > /dev/null
  zle      reset-prompt
}

# cd 命令历史记录切换
vwz_cd_switch_history () {
	print -- "$(dirs -v)"
	echo
	local to_dir=""
	vared -p "to? " -c to_dir
	local num=$(printf "%d" to_dir)
    local to_cd=$(printf "-%d" $(printf "%d" $(($num + 0))))
	cd $(print $to_cd)
	echo
}

# 自动添加cd命令
vwe_user_complete() {
	if [[ -n $BUFFER ]] ; then
		zle expand-or-complete
	else
		BUFFER="cd "
		zle end-of-line
		zle expand-or-complete
	fi
}

zle -N vwz_cd_undo
zle -N vwz_cd_to_parent
zle -N vwz_cd_switch_history
zle -N vwe_user_complete

bindkey "\t" vwe_user_complete

# 开启终端进入最后使用路径
# DIRSTACKFILE="$VWZCACHE/zdirs"
# DIRSTACKSIZE=20

# if [[ ! -f $DIRSTACKFILE ]]; then
# 	touch $DIRSTACKFILE
# fi

# if [[ -f $DIRSTACKFILE ]] && [[ $#dirstack -eq 0 ]]; then
# 	dirstack=( ${(f)"$(< $DIRSTACKFILE)"} )
# 	[[ -d $dirstack[1] ]] && cd $dirstack[1]
# fi

# chpwd() {
#   print -l $PWD ${(u)dirstack} >$DIRSTACKFILE
# }

# 为每个目录建立历史记录
cd () {
	builtin cd "$@"
	fc -W
	local HISTDIR="$VWZCACHE/zshhistory$PWD"
	if [ ! -d "$HISTDIR" ] ; then
		mkdir -p "$HISTDIR"
	fi
	export HISTFILE="$HISTDIR/zhistory"
	touch $HISTFILE
	local ohistsize=$HISTSIZE
	HISTSIZE=0
	HISTSIZE=$ohistsize
	fc -R
}

mkdir -p $VWZCACHE/.zshhistory$PWD
export HISTFILE="$VWZCACHE/.zshhistory$PWD/zhistory"

#*******************************************************************************
#
# command
# zsh prettify command
#
#*******************************************************************************
setopt nonomatch
setopt notify

#漂亮又实用的命令高亮界面
setopt extended_glob
TOKENS_FOLLOWED_BY_COMMANDS=('|' '||' ';' '&' '&&' 'sudo' 'do' 'time' 'strace')

# 定义命令颜色
vwz_recolor-cmd() {
     region_highlight=()
     colorize=true
     start_pos=0
     for arg in ${(z)BUFFER}; do
         ((start_pos+=${#BUFFER[$start_pos+1,-1]}-${#${BUFFER[$start_pos+1,-1]## #}}))
         ((end_pos=$start_pos+${#arg}))
         if $colorize; then
             colorize=false
             res=$(LC_ALL=C builtin type $arg 2>/dev/null)
             case $res in
                 *'reserved word'*)   style="fg=magenta,bold";;
                 *'alias for'*)       style="fg=cyan,bold";;
                 *'shell builtin'*)   style="fg=yellow,bold";;
                 *'shell function'*)  style='fg=green,bold';;
                 *"$arg is"*)
                     [[ $arg = 'sudo' ]] && style="fg=red,bold" || style="fg=blue,bold";;
                 *)                   style='none,bold';;
             esac
             region_highlight+=("$start_pos $end_pos $style")
         fi
         [[ ${${TOKENS_FOLLOWED_BY_COMMANDS[(r)${arg//|/\|}]}:+yes} = 'yes' ]] && colorize=true
         start_pos=$end_pos
     done
}

check-cmd-self-insert() { zle .self-insert && vwz_recolor-cmd }
check-cmd-backward-delete-char() { zle .backward-delete-char && vwz_recolor-cmd }

zle -N self-insert check-cmd-self-insert
zle -N backward-delete-char check-cmd-backward-delete-char

#*******************************************************************************
#
# history
# zsh history setup
#
#*******************************************************************************
setopt HIST_IGNORE_ALL_DUPS
setopt INC_APPEND_HISTORY
setopt EXTENDED_HISTORY
setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt HIST_REDUCE_BLANKS

# HISTFILE="$VWZCACHE/zhist"
HISTSIZE=10000
HISTFILESIZE=100000
HISTCONTROL=ignoreboth ## ignoredups ignorespace erasedups
HISTIGNORE="ls:history"
SAVEHIST=100000

HIST_WHO="`whoami`"
HIST_HOST="`who -u am i 2>/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`"

if [ "$HIST_HOST" = "" ]; then
	HIST_HOST=`hostname`
fi

HIST_USER="$HIST_WHO@$HIST_HOST"

# export HISTTIMEFORMAT="%F %T $HIST_USER"

autoload -Uz history-beginning-search-menu
zle -N history-beginning-search-menu
bindkey '^X^X' history-beginning-search-menu

autoload -U history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end

function vwz_history-incremental-search-backward () {
    zle .history-incremental-search-backward $BUFFER
}

zle -N history-incremental-search-backward vwz_history-incremental-search-backward
bindkey '^R' history-incremental-search-backward

# 将历史记录汇总到一起
function allhistory { cat $(find $VWZCACHE/.zshhistory -name zhistory)}

# 历史记录格式化
function convhistory {
	sort $1 | # 排序
		uniq | # 合并相同
		# sed 's/^:( [0-9]*):[0-9]*;(.*)/\1::\2/g' |
		awk -F'[;]' '{ $1=strftime("%Y-%m-%d %T" ,$1) " |"; print }'
		# sed 's/^:\( [0-9]*\):\([0-9]*\);(.*)/\1::::\2/g'  |
		# awk -F'[;]' '{print strftime("%F %T", $1/1000),$2}'
}

# 查看全部历史记录
function histall { convhistory =(allhistory) |
						  sed '/^.{20} *cd/i\' }

# 查看当前目录
function hist { convhistory $HISTFILE }

# 根据单词出现频率查看全部历史记录 top20
function top! { allhistory | awk -F':[ 0-9]:[0-9];' '{ $1="" ; print }' |
					sed 's/ /\n/g' |
					sed '/^$/d' |
					sort | uniq -c | sort -nr | head -n 20 }

zle -N histall
bindkey '^T' histall

#*******************************************************************************
#
# plugins
# zsh thrid plugins
#
#*******************************************************************************
# 加载插件
function vwz_load_plugins () {
	for plugin ($PLUGINS); do
		if [ -f $VWZ/plugins/$plugin/$plugin.plugin.zsh ]; then
			source $VWZ/plugins/$plugin/$plugin.plugin.zsh
		fi
		# if [ -f $VWZ/plugins/$plugin/$plugin.zsh ]; then
		# 	source $VWZ/plugins/$plugin/$plugin.zsh
		# fi
	done
}

#*******************************************************************************
#
# misc
# zsh misc configure
#
#*******************************************************************************
echo -e -n "\x1b[\x36 q" # changes to steady bar
#以下字符视为单词的一部分
WORDCHARS='*?_-[]~=&;!#$%^(){}<>'

## man
export MANPATH=$PREFIX/man:$MANPATH

#*******************************************************************************
#
# function
# zsh function
#
#*******************************************************************************
setopt CONTINUE_ON_ERROR

## proxy
# slhp
# set local http & https proxy
function slhp()
{
	if [ "$1" = "-a" ]
	then
		path=$2

		if [[ $path =~ ":" ]]
		then
			host=${path%:*}
			post=${path##*:}

			if [[ $host =~ "." ]]
			then
				echo "host is localhost, post is " $post
			else
				host="172.0.0.1"
			fi

			export http_proxy=$host:$post
			export https_proxy=$http_proxy

			echo "set http and https proxy is $host:$post";
		else
			post=${path##*:}

			export http_proxy=127.0.0.1:$post
			export https_proxy=$http_proxy

			echo "set http and https proxy is 127.0.0.1:$2";
		fi
	elif [ "$1" = "-r" ]
	then
		unset http_proxy;
		unset https_proxy;
		echo "unset http and https proxy";
	fi
}

zle -N slhp

## service
# sctl
# run service
function sctl()
{
	if [ "$1" = "-s" ]
	then
		eval "sudo service $2 start";
		echo "sudo service $2 start";
	elif [ "$1" = "-r" ]
	then
		eval "sudo service $2 restart";
		echo "sudo service $2 restart";
	elif [ "$1" = "-q" ]
	then
		eval "sudo service $2 stop";
		echo "sudo service $2 stop";
	elif [ "$1" = "-t" ]
	then
		eval "sudo service $2 status";
		echo "sudo service $2 status";
	elif [ "$1" = "-h" ]
	then
		echo "sctl <option> [service name]"
		echo "     -s       start service";
		echo "     -r       restart service";
		echo "     -q       stop service";
		echo "     -t       status service";
		echo "     -h       help";
	else
		echo "sctl <option> [service name]"
		echo "     -s       start service";
		echo "     -r       restart service";
		echo "     -q       stop service";
		echo "     -t       status service";
		echo "     -h       help";
	fi
}

zle -N sctl

#*******************************************************************************
#
# bindkye
# zsh bindkey
#
#*******************************************************************************
bindkey -e
bindkey ' ' magic-space

#*******************************************************************************
#
# alias
# zsh defautl alias
#
#*******************************************************************************
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
    alias diff='diff --color=auto'
    alias ip='ip --color=auto'

    export LESS_TERMCAP_mb=$'\E[1;31m'     # begin blink
    export LESS_TERMCAP_md=$'\E[1;36m'     # begin bold
    export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
    export LESS_TERMCAP_so=$'\E[01;33m'    # begin reverse video
    export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
    export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
    export LESS_TERMCAP_ue=$'\E[0m'        # reset underline

    # Take advantage of $LS_COLORS for completion as well
    zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
fi

alias ...='cd ..'
alias d="vwz_cd_switch_history"
alias u="cd -"
alias p="cd .."
alias l="ls -lah"
alias s="du --max-depth=1 -h"
alias f="df -h"
alias r="source $HOME/.zshrc"
alias pl="vwz_load_plugins"

hash -d l="/usr/local"
hash -d o="/opt"
hash -d t="/etc"
hash -d d="/dev"
hash -d v="/var"
hash -d m="/media"
hash -d n="/mnt"
hash -d d="$HOME/Download"
hash -d e="$HOME/.emacs.d"

#*******************************************************************************
#
# default load
# zsh default load
#
#*******************************************************************************
PROMPT=$(vwz_prompt_theme)
PLUGINS=(zsh-syntax-highlighting
		 zsh-autocomplete
		 zsh-autosuggestions # https://github.com/zsh-users/zsh-syntax-highlighting.git
		 vwz-ranger)

vwz_load_plugins

bindkey '^U' menu-select

if [ -f $VWZ/custom ]; then
	source $VWZ/custom
fi
